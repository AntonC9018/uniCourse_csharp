# Лабораторная работа 5

- Тема: **Элементарные техники программирования**.
- [Видео](https://www.youtube.com/watch?v=z51K0UhriOk&list=PL4sUOB8DjVlVVw9Yx_tUO7fRPDYeaACXD&index=4)

## Концепты

- Вычисление выражений
- Блоки для ограничения жизни и видимости переменных
- Группирование логически связанных переменных в пользовательские типы (struct, class)
- Функции для удаление повторяющегося кода
- Механизм вызова функций

## Задание

В ассортименте есть 3 товара: напиток, первое и второе.
У каждого из них разные цены (например: 10, 20, 30).

У клиента есть возможность заказать какое-либо количество каждого из этих товаров.
Есть 2 клиента, каждый заказывает разные комбинации вещей.

1. Представьте данную ситуацию в программе.
   Выведите на экран стоимость заказа каждого из клиентов.

   <details>
   <summary>Затрудняюсь понять как это представить</summary>

   У вас есть 2 клиента. У каждого из них по 2 заказа. 
   Это 4 переменные.
   Значения переменных задаются в зависимости от заказа.
   Например:
   
   ```csharp
   int client1_drink = 100; // 100г напитка
   int client1_first = 0; // нет первого
   int client1_second = 250; // 250г второго
   
   int client2_drink = 0; // 0 напитка
   int client2_first = 300; // 300г первого
   int client2_second = 0; // 0 второго
   ```
   </details>

   <details>
   <summary>Получение стоимости</summary>

   ```csharp
   int client1_total = client1_drink * 10 + client_first * 20 + client_second * 30;
   ```
   </details>

2. Отделите работу с отдельными клиентами блоками.
   Внутри блоков, используйте переменные с тем же именем.

3. Создайте класс или структуру цен.
   Упоминайте цены товаров не напрямую, а через переменную этого типа.
   Таким образом, все цены будут логически сгруппированы в одной переменной.

4. Создайте класс или структуру выбора клиента.

5. Сделайте функцию выбора клиента, принимающую параметрами цены и выбор клиента.

   <details>
   <summary>Зачем?</summary>
   
   Чтобы убрать повторяющийся код.
   </details>

   <details>
   <summary>Как?</summary>
   
   Найдите от чего зависит код выбора клиента просмотрев его.
   Зависимость идет от цен, цены и будут первым параметром.
   
   Далее, что изменяется в каждом повторении этого кода?
   Изменяется переменная выбора клиента — это и будут следующий параметр.
   
   Далее, какой результат ожидается от этого куска кода?
   Поиск стоимости.
   Поэтому, возвращаемый тип будет `int`.
   
   ```csharp
   static int CustomerTotal(Prices prices, Choices choices)
   {
       // ...
   }
   ```
   </details>

## Вопросы на анализ

1. ```csharp
   int b = 6;
   F(b);
   Console.WriteLine(b);

   static void F(int a)
   {
       a = 5;
   }
   ```
   
   - Сколько объектов выделится в динамической памяти?
   
     <details>
     <summary>Ответ</summary>
     
     Нисколько. 
     Значение переменной типа `int` попадает во временную память.
     </details>

   - Сколько ячеек будет выделено под переменные?
   
     <details>
     <summary>Ответ</summary>
     
     Одна для переменной `b`, одна для переменной `a` при вызове `F`.
   
     `F` является функцией, а не переменной: для нее не будет ячейки.
     </details>

   - Строчка `a = 5` перезаписывает и переменную `b` после вызова? 
     Другими словами, что будет в `b` после вызова?

     <details>
     <summary>Ответ</summary>
     
     Нет. 
   
     `a` это отдельная переменная, создаваемая под параметр.
     Она существует только на время вызова `F`, после чего она пропадает.
     
     `a = 5` не повлияет никаким образом на `b`.
     </details>

   - Почему у `F` указан `void` как возвращаемый тип?
   
     <details>
     <summary>Ответ</summary>
     
     Потому что `F` не дает значение как результат.
     `F` просто совершает какие-либо действия с памятью.
     </details>
   

2. ```csharp
   int a = 6;
   F(a);
   Console.WriteLine(a);

   static void F(int a)
   {
       a = 5;
   }
   ```
   
   - Ссылается ли переменная `a` во время вызова `F` на ту же ячейку памяти, что и `a` с первой строчки?
   
     <details>
     <summary>Ответ</summary>
     
     Нет.
     
     Это разные переменные с тем же именем.
     Когда вызывается функция, под ее параметры так или иначе будет выделена своя временная память.
     </details>
    
   - Изменится ли сейчас внешняя `a` на 5? Другими словами, что выведется на экран?
   
     <details>
     <summary>Ответ</summary>
     
     Нет. `a` извне функции и `a`, создаваемая при вызове функции, это две разные переменные.
   
     Выведется 6.
     </details>
    
3. ```csharp
   string a = "hello";
   F(a);
   Console.WriteLine(a);

   static void F(int b)
   {
       b = "world";
   }
   ```
   
   - Сколько объектов в динамической памяти выделится?
   
     <details>
     <summary>Ответ</summary>
    
     Выделится 2 объекта, один под строку `"hello"` и один под строку `"world"`.
     </details>

   - Изменится ли объект, адрес которого изначально был в `a`?
   
     <details>
     <summary>Ответ</summary>
    
     Перезаписью адреса в переменной априори невозможно изменить значение объекта.
     Более того, значение объекта строки невозможно изменить априори, поскольку
     этот тип `immutable` по своему дизайну.
     </details>

   - Изменится ли сейчас адрес из `a` на адрес объекта `"world"`? Другими словами, что выведется на экран?
   
     <details>
     <summary>Ответ</summary>
    
     Нет, это все так же разные переменные, несмотря на то, что они хранят ссылки.
     </details>

    
4. ```csharp
   A b = new()
   {
       value = 1,
   };
   F(b);
   Console.WriteLine(b.value);
   

   static void F(A a)
   {
       a.value = 2;
   }
   
   struct A
   {
       public int value;
   }
   ```
   
   - Изменится ли `value` внутри `b`?
     
     <details>
     <summary>Ответ</summary>
    
     Нет. 
     
     При передаче значения типа `A` в функцию, создается переменная.
     Эта переменная функционирует точно так же, как и обычная переменная.
     В нее можно вписать, с нее можно считать, она имеет тип и расположение в памяти тоже идентично:
     (выделяется по ячейке во временной памяти для каждого поля, 
     поскольку `A` это `struct`, то есть тип-значение).
     
     При создании переменной типа `A` создается по ячейке для каждого поля (то беж, 1 ячейка для поля `value`).
     То же произойдет и для параметра. Параметр получит значение из переменной при инициализации.
     
     Переменная параметра независима от переменной `b` в основном блоке.
     </details>
    
   - Как изменится исход, если вместо `b` назвать ее `a`?
   
     <details>
     <summary>Ответ</summary>
     
     Никак. Они все так же будут независимы.
     </details>
    
   - Как изменится ход программы, если сменить `struct` на `class`?
     Что насчет объектов в динамической памяти? 
     Исхода программы? 
     Того, что хранится в переменных?
   
     <details>
     <summary>Ответ</summary>
     
     Это сделает так, что переменные этого типа будут хранить не все поля напрямую, 
     а ссылку на объект в динамической памяти с этими полями.
     
     Оператор `new` выделяет этот объект в динамической памяти.
     Соответственно, будет выделен 1 объект в динамической памяти.
     
     Поскольку переменная параметра работает так же как обычная,
     она тоже будет хранить ссылку, а не поля.
     Ей вы передаете тут ту же ссылку, что и в переменной снаружи.
     
     По итогу, обе переменные ссылаются на тот же объект в динамической памяти, 
     следовательно, вы увидите измененное значение.
     </details>
