# Лабораторная работа 2

- Тема: **Pipelines**.
- [Видео](https://www.youtube.com/watch?v=X4IDL3CmV-A&list=PL4sUOB8DjVlXKTknA5IW75BGwcTw6PU3r&index=3)
- [Поэтапный код из видео](https://github.com/AntonC9018/uniCourse_csharp/pull/3) (смотрите коммиты)

## Концепты

- Абстракция (ссылка на код по имени)
- Полиморфизм (интерфейс)
- Контекст
- Паттерн Адаптер
- Паттерн Strategy (передача действия параметром)
- Интроспекция
- Data-Oriented (манипуляция операций как с данными)
- Паттерн Декоратор (Wrapper)

## Задания

1. Создать свой pipeline, как в видео, но на свою тематику.
2. Сконфигурируйте тестовый pipeline в основной функции с демонстрацией использования.

**Дальнейшие задания (как минимум 4 на выбор)**:

- Используйте generics чтобы задавать тип контекста извне.
  Сделайте `Pipeline` и `IPipelineStep` зависимыми от типа контекста 
  (то есть, `Pipeline<TContext>` и `IPipelineStep<TContext>`).

  Используйте 2 разных вида контекста при демонстрации.
 
- Улучшите систему интроспекции. 
  Например, пусть метод принимает `StringBuilder`, и добавляет свое описание туда.

  Сделайте так же вспомогательные функции на основе этой новой системы.
  Например, функция для печати всех шагов.

  > Можете также использовать паттерн Visitor.
 
- Используйте паттерн Декоратор, чтобы создать хотя бы 2 `PipelineStep`-а, которые подойдут вашей тематике.
  Выполняйте код до, после или и до и после шага, сохраненном в них.

  ```
  public void Execute(Context context)
  {
      // до
      _step.Execute(context);
      // после
  }
  ```

  Можно также сделать `PipelineStep`, который выполняет еще один `Pipeline`, встроенный в него.

- Сделайте как минимум 3 высокоуровневых методов для изменения действий в массиве.
  Например, 
  `ReplaceFirstInstance(Type typeToReplace, IPipelineStep newStep)`,
  `ReplaceAll(Type typeToReplace, IPipelineStep newStep)`,
  `WrapAll(Type typeToWrap, Func<IPipelineStep, IPipelineStep> wrapFunc)`,
  `MoveTo(Type typeToMove, int index)`.
 
- Используйте паттерн Singleton для того, 
  чтобы избежать повторного создания `PipelineStep`-ов, 
  независящих от внешнего контекста.
  (Создается статическое поле, передаете поле вместо создания объекта.)

- Сделайте unit test-ы для реализованного функционала.

- Сделайте возможным работу вашего pipeline-а как Responsibility Chain 
  (отдельные шаги могут решить завершить выполнение последующих шагов).
  Для этого, можете хранить в контексте поле `IsDone`.
  Не выполняйте следующий этап, если это поле выставлено.
