# Лабораторная работа 12

- Тема: **инкапсуляция**.
- [Видео](https://www.youtube.com/watch?v=IESVXL16OBA&list=PL4sUOB8DjVlVVw9Yx_tUO7fRPDYeaACXD&index=11), 

## Идеи

- Модификатор доступа `private`
- Рефакторинг
- Конструкторы для инициализации скрытых полей
- `private` конструкторы
- Свойства
- Контракт функции
- Контракт класса
- Специфика абстракции функции
- Специфика абстракции класса

## Задание

1. Инкапсулируйте поле массива, сделав его `private`.
   Создайте конструктор для его инициализации.

   > Если есть прямое использование этого поля извне класса,
   > сделайте новый метод, и уберите код его использования в этот метод.
   
   <details>
   <summary>Зачем?</summary>

   Теперь пользователь извне класса может только догадываться о существовании массива
   с данными, но не сможет получить к нему прямой доступ.

   В будущем вы теперь сможете переделать то, как сохранены книги, во что угодно:
   - по массиву для каждого свойства;
   - словарь из названия в книгу;
   - отдельные списки для взятых и не взятых книг;
   - список вместо массива;
   - обращение в таблицу в базе данных;
   - и т.д.

   Поскольку прямого доступа к полю извне нет,
   вы можете быть уверены, что сломаются только методы в самом классе,
   и вам придется исправлять лишь их.

   Еще одно преимущество в том, что теперь лишь методы класса способны
   внести изменения в массив. 
   Извне невозможно просто так перезаписать
   какую-то книгу, не пройдя при этом через один из методов.
   </details>

2. Измените внутреннее представление книг с одного списка на 2 `List<Book>`:
   один для взятых книг, другой для свободных.

   Обновите все методы, которые обновляют книги, чтобы они работали корректно.

   Проверьте корректность методов для всех возможных предусловий вызова.

   > Это задание есть для демонстрации того, что внешний код не поменяется.

3. Сделайте абстракцию для фильтрации книг (`LibraryFilter`).

   Должны поддерживаться как минимум следующие фильтры:
   - состояние книги (`enum`: взята, невзята, любое);
   - содержание строки в имени (`string?`);
   - отсутствие строки в имени;
   - имя автора (добавьте поле);
   - начало имени.

   Фильтры сделайте полями этой абстракции.

4. Создайте метод в `Library`, который принимает `LibraryFilter`,
   и печатает только книги, которые подошли по фильтру.

   <details>
   <summary>Почему не получится метод создать в <code>LibraryFilter</code></summary>

   Потому что массив с книгами в `Library` уже инкапсулирован.
   Его можно просматривать только в методах в `Library`.

   Это и есть один из недостатков этого подхода — **о всех возможных взаимодействиях
   с книгами должно быть известно и абстракции, ответственной за их хранение.**
   </details>

   <details>
   <summary>А как это сделать? Я не знаю</summary>

   Была тема по алгоритмам. 
   Разбейте задачу на подзадачи.
   </details>

5. Определите *контракт класса* `LibraryFilter`.
   Для этого подумайте о том, какие значения полей имеют смысл.

   Например, строковые фильтры не должны быть пустой строкой,
   а должны быть `null` в случае, когда их не надо применять.

   `enum` значения обязательно должны быть одним из определенных.

6. Реализуйте гарантии контракта класса, 
   используя свойства для отдельных фильтров.

   Используйте `Debug.Assert` для проверки контракта в свойствах.

   <details>
   <summary>Ничего не понял</summary>

   ```csharp
   sealed class LibraryFilter
   {
       public string? _nameInclude;

       public string? NameInclude
       {
           get
           {
               return _nameInclude;
           }
           set
           {
               Debug.Assert(value != "");
               _nameInclude = value;
           }
       }

       // ...
   }
   ```
   </details>

7. Сделайте еще один класс, `InputLibraryFilter`,
   который будет в дальнейшем использоваться при вводе желаемого фильтра с консоли.
   
   Этот фильтр будет производить coercion из строки, введенной пользователем, в фильтр.

   - Сделайте функцию ввода фильтра с консоли.
     Сделайте ввод всех фильтров по очереди и попытку их сохранить в `InputLibraryFilter`,
     используя его методы.

     <details>
     <summary>Ничего не понял</summary>

     ```csharp
     LibraryFilter ReadLibraryFilter()
     {
         var ret = new LibraryFilter();
         var inputFilter = new InputLibraryFilter(ret);

         while (true)
         {
             Console.Write("Status (Free, Taken, Any): ");
             var str = Console.ReadLine();
             if (!inputFilter.Status(str))
             {
                 Console.WriteLine("Invalid input");
                 continue;
             }
             break;
         }

         // ...

         return ret;
     }
     ```
     </details>

   - `InputLibraryFilter` будет хранить в себе `LibraryFilter` как поле,
     и будет сохранять в него фильтры с меньшим количеством проверок.

     Например, если попытаться сохранить пустую строку как фильтр для имени,
     `InputLibraryFilter` преобразует ее в `null` перед тем, как записать в `LibraryFilter`.

     <details>
     <summary>Не понял</summary>

     ```csharp
     sealed class InputLibraryFilter
     {
         private readonly InputFilter _impl;

         public void NameInclude(string? str)
         {
             if (str == "")
             {
                 str = null;
             }
             _impl.NameInclude = str;
         }

         // ...
     }
     ```
     </details>

   - В случае `enum`-a сделайте функцию, 
     которая будет возвращать `false` в случае неудачи.

     <details>
     <summary>Чего???</summary>

     ```csharp
     sealed class InputLibraryFilter
     {
         private readonly InputFilter _impl;

         public bool Status(string? str)
         {
             if (str == null)
             {
                 return false;
             }
             bool ok = Enum.TryParse(
                value: str,
                ignoreCase: true,
                result: out TakenStatusFilter status);
             if (!ok)
             {
                 return false;
             }
             _impl.TakenStatus = status;
         }
     }
     ```
     </details>
   - Примените фильтр в функции `main`.

   - Примените абстракцию `InputLibraryFilter` отдельно, 
     для теста ввода фиксированных данных, а не от пользователя.

## Что дает функция как абстракция?

Функция содержит **несколько шагов**, но вызывающий код видит только ее **вызов по имени**.
Использование функций дает следующее:

1. *Увеличивает уровень абстракции* у кода, т.е. для части действий теперь есть свое имя.

   Это позволяет уменьшить смысловую нагрузку, когда цель понять больший кусок
   кода на высоком уровне, не вдаваясь в каждую деталь реализации.

   Недостаток этого в том, что теперь все действия большего куска кода,
   использующего эту абстракцию, будет понять сложнее, чем если бы ее не было.

2. Функция — это те же самые действия, но как алгоритм на более высоком уровне абстракции.
   Другой алгоритм теперь способен использовать эту абстракцию как подалгоритм.

   Это полезно в том случае, когда данные операции используются больше,
   чем в одном месте в коде, и *позволяет избежать повторение того же кода*.

3. Выделяются *зависимости функции* в строгие параметры.
   Таким образом понятнее, от какого контекста зависит этот кусок кода.

4. *Скрыты данные*, необходимые для реализации функции.
   Того же можно достичь, используя блок.

Можно сказать, что функция **инкапсулирует конкретные шаги**, которые выполнятся при ее вызове,
а так же **временные данные**, 
необходимые для ее выполнения, 
давая **явный интерфейс** (параметры и возвращаемое значение).

Объяснения этих идей ниже сгенерировал ИИ.

### 1. Увеличение уровня абстракции

> Функция содержит несколько шагов, но вызывающий код видит только имя функции.

У нас есть код, который должен проверять корректность пользовательского ввода.
Без абстракции — всё в одном месте:

```csharp
bool ok = !string.IsNullOrWhiteSpace(input)
    && input.Length >= 3
    && input.All(char.IsLetterOrDigit)
    && char.IsUpper(input[0]);
```

Трудно понять, *что именно* проверяется.

Создаём функцию:

```csharp
bool IsValidUserName(string name)
{
    bool notEmpty = !string.IsNullOrWhiteSpace(name);
    bool longEnough = name.Length >= 3;
    bool allAlphanumeric = name.All(char.IsLetterOrDigit);
    bool startsWithUpper = char.IsUpper(name[0]);

    return notEmpty && longEnough && allAlphanumeric && startsWithUpper;
}
```

Теперь вызывающий код:

```csharp
bool ok = IsValidUserName(input);
```

**Что произошло:**

* Мы подняли абстракцию — теперь в коде видно именно "проверить имя", а не мешанину из условий.
* Читая основной алгоритм, не нужно читать детали проверки.
* Но чтобы понять *как* работает проверка, 
  нужно идти внутрь функции — это обратная сторона абстракции.

### 2. Использование функции как подалгоритма (избежание дублирования)

> Мы выделяем функцию, чтобы другие алгоритмы могли использовать её повторно.

Представим, что мы считаем итоговую стоимость с учётом скидки.

```csharp
decimal ApplyDiscount(decimal price, decimal discount)
{
    return price - (price * discount);
}
```

Теперь два разных алгоритма могут пользоваться этим подалгоритмом:

```csharp
decimal CalculateCartTotal(decimal[] prices)
{
    decimal sum = prices.Sum();
    return ApplyDiscount(price: sum, discount: 0.1m);
}

decimal CalculateServiceFee(decimal baseFee)
{
    return ApplyDiscount(price: baseFee, discount: 0.05m);
}
```

**Что произошло:**

* Код вычисления скидки не повторяется.
* Разные части программы используют одну и ту же абстракцию.

### 3. Строгие параметры выявляют зависимости функции

> Функция вынуждает явно передать всё, от чего она зависит.
> Это делает её поведение прозрачным.

Без функции:

```csharp
int width = rect.Width;
int height = rect.Height;
int area = width * height;
```

С функцией:

```csharp
int ComputeArea(int width, int height)
{
    return width * height;
}
```

Вызов:

```csharp
int area = ComputeArea(rect.Width, rect.Height);
```

**Что произошло:**

* Мы явно видим зависимость: функция зависит от *width* и *height*.
* Внутри алгоритма теперь не нужно держать в голове всю логику вычисления.
* Чтобы понять, что требуется функции — достаточно посмотреть на параметры.

### 4. Сокрытие данных, необходимых для реализации

> Функция может использовать внутренние данные (локальные переменные),
> которые вызывающий код **не обязан и не должен знать**.

Функция нормализует строку по нескольким правилам.

```csharp
string Normalize(string text)
{
    string trimmed = text.Trim();              // скрытые данные
    string noDoubleSpaces = RemoveDoubleSpaces(trimmed); // скрытые данные
    string lower = noDoubleSpaces.ToLower();   // скрытые данные
    return lower;
}

string RemoveDoubleSpaces(string text)
{
    while (text.Contains("  "))
        text = text.Replace("  ", " ");
    return text;
}
```

Вызов:

```csharp
string clean = Normalize(text: rawInput);
```

**Что произошло:**

* Вызывающий код не знает о `trimmed`, `noDoubleSpaces`, `lower`.
* Он знает только: "Нормализуй строку".
* Все промежуточные шаги и временные данные *инкапсулированы внутри*.

## Что дает класс как абстракция

> Объяснение от ChatGPT

Класс — это более сильная форма абстракции, чем функция.
Если функция инкапсулирует **одну операцию и её временные данные**,
то класс инкапсулирует **целый набор операций и долгоживущее состояние**.

Класс предоставляет:

1. **Связность данных и поведения**
2. **Инкапсуляцию состояния**
3. **Инкапсуляцию операций**
4. **Чёткую границу публичного интерфейса**
5. **Стабильный контракт при изменении реализации**

Ниже — разбор этих аспектов.

### 1. Класс связывает *состояние* и *операции над ним*

Класс позволяет хранить данные и предоставить к ним подходящие операции.
Это делает код естественным — объект «знает», как с собой работать.

Пример:

```csharp
public class Counter
{
    private int _value;    // состояние

    public void Increment(int amount)
    {
        _value += amount;  // операция меняет состояние
    }

    public int Value => _value;
}
```

Объект:

```csharp
var c = new Counter();
c.Increment(5);
int v = c.Value;
```

Состояние и операции — одной логической единицы.

### 2. Инкапсуляция состояния

Класс может скрыть своё внутреннее состояние и предоставить к нему контролируемый доступ.

Это позволяет:

* гарантировать корректность данных
* предотвращать использование внутренних деталей
* менять внутреннее представление без изменения внешнего интерфейса

Пример:

```csharp
public class Temperature
{
    private double _celsius;     // скрытые данные

    public double Celsius => _celsius;
    public double Fahrenheit => _celsius * 9 / 5 + 32;

    public void SetCelsius(double value)
    {
        if (value < -273.15) throw new ArgumentException();
        _celsius = value;
    }
}
```

Внутренняя логика и проверки скрыты — это полноценная инкапсуляция данных.

### 3. Инкапсуляция операций

Класс может скрывать вспомогательные шаги, так же как функция,
но при этом они могут использовать и изменять *долгоживущее состояние объекта*.

Пример:

```csharp
public class Connection
{
    private bool _isOpen;

    public void Open()
    {
        if (!_isOpen)
            EstablishPhysicalConnection();   // скрытый шаг
    }

    private void EstablishPhysicalConnection()
    {
        // детали реализации скрыты
        _isOpen = true;
    }
}
```

Вызов:

```csharp
var conn = new Connection();
conn.Open();            // видна только высокоуровневая операция
```

### 4. Явная граница между *интерфейсом* и *реализацией*

Функции дают интерфейс только в форме параметров и возвращаемого значения.
Класс даёт гораздо более структурированную границу:

* публичные методы/свойства — интерфейс
* private-поля, private-методы — реализация

Такая граница позволяет безопасно развивать код.

Пример изменения, которое *не ломает* пользователей класса:

```csharp
// раньше
private int _amount;

// потом
private decimal _amount;
```

Если интерфейс не меняется — код, который использует класс, не ломается.

### 5. Класс — это стабильный контракт, который можно развивать

Класс позволяет:

* добавлять новые поля
* оптимизировать алгоритмы
* менять внутреннее хранение
* добавлять кэширование
* добавлять проверки
* менять вспомогательные методы

…и всё это без изменения кода, который пользуется классом.

Класс — это «точка расширения» программы.

## Коротко: различие абстрации функции и класса

| Характеристика        | Функция                           | Класс                                   |
| --------------------- | --------------------------------- | --------------------------------------- |
| Состояние             | нет (только временные переменные) | есть, живёт между вызовами              |
| Инкапсуляция данных   | только временные данные           | полноценная инкапсуляция состояния      |
| Инкапсуляция операций | одна операция                     | множество операций, связанных с данными |
| Интерфейс             | параметры + return                | набор методов/свойств                   |
| Поведение             | одноразовый алгоритм              | объект как долгоживущая сущность        |
| Объединяет логику     | частично (одна операция)          | полностью (данные + методы)             |
