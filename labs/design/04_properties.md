# Лабораторная работа 3

- Тема: **Возможности представления свойств объекта в системе**.
- Видео пока нет
- [PR](https://github.com/AntonC9018/uniCourse_csharp/pull/8)

## Концепты

1. Иерархии классов:
    - Задача свойств статическим образом через иерархию классов
    - Использование интерфейсов, чтобы обойти ограничение на множественное наследование
    - Паттерн traits (избежание дублирования хранения свойств)
    - Минусы подхода (статическая структура, нельзя конфигурировать свойства во время выполнения программы)

2. `object[]`:
    - Примитивный подход к решению - массив свойств (`object[]`)
    - Компонент (группирование одного или больше связанных свойств)
    - Использование тега для различения примитивных типов

3. Подход "Fat Struct":
    - Простота подхода
    - Минусы подхода (трата памяти, обязательные проверки на наличие свойства)

4. Самый часто используемый подход - ассоциативный массив:
    - Хранение данных по строковому ключу, каст при получении значения
    - Статическое типизирование ключа, используя generic обертку
    - Использование integer ключа и реестра (нет в видео)
    - Минусы подхода (память идет на создание самих объектов под каждое свойство)

5. Продвинутый уровень: ECS (Entity Component System):
    - Sparse Set (например, [EnTT](https://skypjack.github.io/2020-08-02-ecs-baf-part-9/))
    - Архетипический ECS (например, [Unity DOTS](https://unity.com/ecs))


## Задание

(Не запрещается использование ChatGPT для пояснения задания, или для отсылки на релевантную информацию).

1. Изучите, идентифицируйте и дайте пример использования контекста с динамическими свойствами, 
   определенный в библиотеке, для передачи данных, неизвестных библиотеке.

   Например, система аутентификации в ASP.NET Core (`AuthenticationProperties.Items`),
   `ActionFilter` в MVC (`ActionExecutingContext.ActionParameters`),
   middleware (`HttpContext.Items`),
   FluentValidation (`ValidationContext.RootContextData`),
   HotChocolate (`IResolverContext.ContextData`),
   WPF (Behaviors), etc.

2. Объясните, почему подход `FatStruct` не пойдет, если проект, определяющий его,
   является библиотекой, не знающей о своих пользователях.
   
3. Достигните возможности одного проекта работать с сущностями, определенными в другом проекте.
   Используйте один из динамических подходов (`object[]` или словарь).
   Сделайте возможным проекту, потребляющему библиотеку, задавать как части сущностей,
   так и операции, которые будут выполняться с ними на основе этих данных.

   Другими словами, создайте систему с контекстом, как в библиотеках в 1-м пункте,
   но сами. Изолируйте ее от потребительского проекта.
   
4. Сделайте централизованный реестр ключей, чтобы 2 проекта, потребляющих 
   тот же контекст или базовый тип сущности из библиотеки,
   не смогли записать разные несовместимые данные по тому же ключу.
   
   Используйте или `int` в обертке как ключ, или давайте пользователю пытаться добавить свой ключ
   в глобальный реестр библиотеки, и давайте ошибку, если такой уже был добавлен.

   Используйте паттерн типизированного ключа, используя генерик.

5. Задокументируйте, что вы изучили и ваш ход мыслей при выполнении разных подходов, в markdown документе.
   

